# -*- coding: utf-8 -*-
"""
/***************************************************************************
 AzureMapsPlugin
                                 A QGIS plugin
 Azure Maps plugin for QGIS 3
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-06-04
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Microsoft Corporation
        email                : japark@microsoft.com, xubin.zhuge@microsoft.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import time
from PyQt5.QtCore import *
from PyQt5.QtGui import *
from PyQt5.QtWidgets import *

from qgis.core import *

# Initialize Qt resources from file resources.py
from QGISPlugin.models.Collection import Collection
from QGISPlugin.models.Ontology import Ontology
from .helpers.Constants import Constants
from .resources import *

# Import the code for the dialog
from .azure_maps_plugin_dialog import AzureMapsPluginDialog

from .helpers.progress_iterator import ProgressIterator
from .helpers.level_picker import LevelPicker
from .helpers.validation_utility import ValidationUtility
from .helpers.AzureMapsPluginLogger import AzureMapsPluginLogger
from .helpers.AzureMapsPluginDialogBox import AzureMapsPluginDialogBox
from .helpers.AzureMapsRequestHandler import AzureMapsRequestHandler

from shapely.geometry import mapping, shape

import os.path
import requests
import urllib.parse
import json
from itertools import starmap
from multiprocessing import Pool


class AzureMapsPlugin:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        self.dlg = AzureMapsPluginDialog(self.iface)
        self.ltv = self.iface.layerTreeView()
        self.msgBar = self.iface.messageBar()
        self.pluginToolbar = self.iface.pluginToolBar()
        self.model = self.ltv.layerTreeModel()
        self.root = QgsProject.instance().layerTreeRoot()
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value("locale/userLocale")[0:2]
        locale_path = os.path.join(
            self.plugin_dir, "i18n", "AzureMapsPlugin_{}.qm".format(locale)
        )

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > "4.3.3":
                QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None
        self.current_dataset_id = None
        self.ontology = None
        self.current_index = None
        self.schema_map = {}
        self.new_feature_list = []
        self.id_map = {}
        self.relation_map = {}
        self.enum_ids = {}
        self.areFieldsValid = {}
        self.areAllFieldsValid = True
        self.base_group = None
        self._progress_base = None
        self.apiName = Constants.FEATURES
        self.apiVersion = Constants.API_Versions.V20220901PREVIEW
        self.internalDelete = False

        self.dialogBox = AzureMapsPluginDialogBox(self.iface)
        self._create_helpers()

    def _create_helpers(self):
        """Create helpers for the plugin. Setup Logger and AzureMapsRequestHandler"""
        self.logger = AzureMapsPluginLogger(self.iface,
                            hideSubscriptionKey=True,
                            subscription_key=self.dlg.sharedKey.text(),
                            autoLogToFile=True,
                            logFolder=self.dlg.logsFolderPicker.filePath(), 
                            debugLog=False)
        self.requestHandler = AzureMapsRequestHandler(
            subscription_key=self._get_subscription_key(),
            geography=self.dlg.geographyDropdown.currentText(),
            api_version=self.apiVersion,
            logger=self.logger
        )
    
    def _setup_helpers(self):
        """Setup helpers once the parameters are set by the user."""
        self.logger.set_parameters(
            subscription_key=self._get_subscription_key(),
            dataset_id=self.dlg.datasetId.text(),
            logFolder=self.dlg.logsFolderPicker.filePath()
        )
        self.requestHandler.set_parameters(
            subscription_key=self._get_subscription_key(),
            geography=self.dlg.geographyDropdown.currentText(),
            api_version=self.apiVersion,
            logger=self.logger
        )

    def _get_subscription_key(self):
        return self.dlg.sharedKey.text()

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.
        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        win = QWidget()
        l1 = QLabel()
        l1.setPixmap(QPixmap(Constants.Paths.PLUGIN_CIRCLE_ICON))

        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate("AzureMapsPlugin", message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=False,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None,
    ):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """
        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)
        action.setCheckable(True)
        action.setChecked(False)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToVectorMenu(self.menu, action)
        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
        # Add the plugin icon on the Plugin Toolbar
        config_path = (
            QgsApplication.qgisSettingsDirPath().replace("\\", "/")
            + Constants.Paths.RELATIVE_CONFIG_PATH
        )
        plugin_settings = QSettings(config_path, QSettings.IniFormat)
        icon_path = Constants.Paths.PLUGIN_CIRCLE_ICON
        self.add_action(
            icon_path,
            text=self.tr(Constants.AZURE_MAPS),
            callback=self.run,
            parent=self.iface.mainWindow(),
        )

        # If plugin has been installed for the first time, show a welcome message
        if plugin_settings.value("freshinstall", None) is None:
            plugin_settings.setValue("freshinstall", True)
            self._open_welcome_message()

        # Initialize Level Control
        self._configure_level_picker()

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginVectorMenu(self.tr(Constants.AZURE_MAPS), action)
            self.iface.removeToolBarIcon(action)

        # Delete toolbar level picker on plugin unload
        if hasattr(self, "toolbar_level_combobox_action"):
            self.iface.pluginToolBar().removeAction(self.toolbar_level_combobox_action)

    def run(self):
        """Run method that performs all the real work"""
        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start:
            self.first_start = False
            self.dlg.getFeaturesButton.clicked.connect(self.get_features_clicked)
            self.dlg.getFeaturesButton_2.clicked.connect(self.get_features_clicked)
            self.dlg.closeButton.clicked.connect(self.close_button_clicked)
            self.dlg.floorPicker.currentIndexChanged.connect(self.floor_picker_changed)
            self.dlg.setWindowFlags(Qt.WindowStaysOnTopHint | Qt.WindowSystemMenuHint)

        # Close dialog if it is already open - mocks dialog toggle behavior
        if self.dlg.isVisible():
            self.dlg.hide()
            return

        self._getFeaturesButton_setEnabled(True)
        # show the dialog
        self.dlg.show()
        # Run the dialog event loop
        result = self.dlg.exec_()

    def close_button_clicked(self):
        self.dlg.hide()
        self.actions[0].setChecked(False)

    def floor_picker_changed(self, index, force=False):
        if index < 0:
            return

        ordinal = str(self.level_picker.get_ordinal(index))

        if self.current_index == index:
            return
        self.current_index = index
        for toplevel_layer in QgsProject.instance().layerTreeRoot().children():
            for child_treeLayer in toplevel_layer.children():
                if isinstance(child_treeLayer, QgsLayerTreeLayer):
                    layer = child_treeLayer.layer()
                    if isinstance(layer, QgsVectorLayer):
                        if "floor" in [field.name() for field in layer.fields()]:
                            layer.rollBack()
                            layer.setSubsetString("floor = " + ordinal)
                        if "levels" in [field.name() for field in layer.fields()]:
                            layer.rollBack()
                            layer.setSubsetString(
                                "array_contains(levels, '"
                                + self.ordinal_to_level[int(ordinal)]
                                + "')"
                            )

        for group in self.root.children():
            for child in group.children():
                if isinstance(child, QgsLayerTreeLayer):
                    layer = child.layer()
                    if "floor" in [field.name() for field in layer.fields()]:
                        layer.rollBack()
                        layer.setSubsetString("floor = " + ordinal)
                    if "levels" in [field.name() for field in layer.fields()]:
                        layer.rollBack()
                        layer.setSubsetString(
                            "array_contains(levels, '"
                            + self.ordinal_to_level[int(ordinal)]
                            + "')"
                        )

    def set_creator_status(self, status):
        self.dlg.creatorStatus.setText(status)
        self.dlg.creatorStatus_2.setText(status)
        QApplication.processEvents()

    def get_request_base(self, url, base_error, progress, **kwargs):
        """
        Base function for get requests + error handling
        Need this mainly for handling errors - stop progress bar and show error message on message bar
        """
        resp = self.requestHandler.get_request(url, **kwargs)
        self._get_request_base_error(resp, base_error, progress) # call error handling function
        return resp["response"]
    
    def _get_request_base_error(self, resp, base_error, progress):
        """
        Error handling for get requests
        Show error message on message bar
        Stop progress bar
        """
        if resp["error_text"]:
            if "response" in resp and resp["response"]: # status code is available
                self._apply_progress_error_message(
                    "{} Response status code {}. Error: {}".format(
                        base_error, resp["response"].status_code, resp["error_text"]), 
                        progress, self.msgBar
                )
            self._apply_progress_error_message( # status code is not available - generic error
                "{} Please try again later. Error: {}".format(base_error, resp["error_text"]),
                progress,
                self.msgBar,
            )
            return False
        return True

    def get_features_clicked(self):
        self.close_button_clicked()
        self._getFeaturesButton_setEnabled(False)
        self.level_picker.clear()
        dataset_id = self.dlg.datasetId.text()
        self._setup_helpers()
        self.logger.QLogInfo("{} Loading Azure Maps dataset with ID: {} {}".format('-'*15, dataset_id, '-'*15))

        # Condition: Only one dataset is allowed at a time
        if (
            self.current_dataset_id is not None
            and self.current_dataset_id != dataset_id
        ):
            warning_response = self.dialogBox.QMessageWarn(
                title="Warning",
                text="""We can only load one dataset at a time. 
                        \nWould you like to remove the existing dataset and load a new dataset?\n\n
                        To remove: {} \nTo add: {}""".format(self.current_dataset_id, dataset_id),
                buttons=QMessageBox.Yes | QMessageBox.Cancel,
            )

            if warning_response == QMessageBox.Cancel:
                return self._getFeaturesButton_setEnabled(True)
            if warning_response == QMessageBox.Yes:
                self.root.removeChildNode(self.root.findGroup(self.current_dataset_id))
            else:
                self.msgBar.pushMessage(
                    "Error",
                    "An unexpected error has occurred.",
                    level=Qgis.Critical,
                    duration=0,
                )
                return self._getFeaturesButton_setEnabled(True)

        self.current_dataset_id = dataset_id

        # Determine bounding box.
        bbox = ""
        min_x = self.dlg.extentWest.text().strip()
        min_y = self.dlg.extentSouth.text().strip()
        max_x = self.dlg.extentEast.text().strip()
        max_y = self.dlg.extentNorth.text().strip()

        if min_x != "" or min_y != "" or max_x != "" or max_y != "":
            if min_x == "":
                min_x = "-180"
            if min_y == "":
                min_y = "-90"
            if max_x == "":
                max_x = "180"
            if max_y == "":
                max_y = "90"
            bbox = "&" + urllib.parse.urlencode(
                {"bbox": "{},{},{},{}".format(min_x, min_y, max_x, max_y)}
            )

        # Start progress dialog
        progress = ProgressIterator(
            msg="Downloading dataset", window_title="Retrieving features..."
        )

        # Override progress dialog config
        self._progress_base = progress._get_progress_dialog()
        self._progress_base.setFixedSize(
            self._progress_base.width() + 250, 150
        )
        self._progress_base.setCancelButton(None)  # Hide cancel button
        self._progress_base.setWindowFlags(
            Qt.WindowSystemMenuHint | Qt.WindowStaysOnTopHint
        )  # Disable close button, always on top
        self._progress_base.show()  # Immediately show the progress bar
        QApplication.processEvents()

        # Get dataset metadata.
        self.features_url = Constants.API_Paths.BASE.format(host=self.requestHandler.host, apiName=self.apiName, datasetId=dataset_id)
        r = self.get_request_base(
            Constants.API_Paths.GET_COLLECTIONS.format(base=self.features_url),
            "Unable to read dataset metadata.",
            progress,
        )
        self.ontology = Ontology(r["ontology"])

        # If successful, get all the layers.
        # Create a new dataset group layer if it doesn't exist, otherwise override the existing group layer
        if self.base_group is None:
            self.base_group = self.root.insertGroup(0, dataset_id)
        else:
            self.base_group.removeAllChildren()
            self.base_group.setName(dataset_id)

        # Add a group layer delete event listener
        self.root.removedChildren.connect(self._on_layer_removed)

        # Get features from each collection.
        collections = r["collections"]

        if dataset_id not in self.id_map:
            self.id_map[dataset_id] = {}

        id_map = self.id_map[dataset_id]
        collection_order = Collection.get_order(self.ontology)

        other_collections = [
            c["id"] for c in collections if c["id"] not in collection_order
        ]
        # ! List must be updated if more enums will be exposed in other collections !
        enums_collection = [Constants.COLLECTIONS.CTG, Constants.COLLECTIONS.VRT, Constants.COLLECTIONS.OPN]

        progress_max = 2*(len(collection_order) + len(other_collections)) + 2
        self._progress_base.setMaximum(progress_max)

        # Clear existing enum layers, if exists
        # Create enum group layer, if not exists
        enums_group_name = "Enums  " + dataset_id
        enums_group = self.root.findGroup(enums_group_name)
        if enums_group is None:
            enums_group = self.root.insertGroup(1, enums_group_name)
        else:
            enums_group.removeAllChildren()
        # Construct Enum List
        enums_set = set()

        level_layer = category_layer = directoryInfo_layer = unit_layer = areaElement_layer = structure_layer = \
            opening_layer = lineElement_layer = pointElement_layer = facility_layer = verticalPenetration_layer = \
            zone_layer = None

        # Loop through collections and create tasks to get data and metadata(definition)
        taskList = []
        for collection in collections:
            _id = collection["id"]
            links = collection["links"]

            data_link = next(link for link in links if link["rel"] == "items")
            globals()['data_task_'+_id] = QgsTask.fromFunction(
                "Getting " + _id + " collection",
                self.requestHandler.get_request_parallel,
                _id, "data", data_link["href"] + bbox, 50
            )
            QgsApplication.taskManager().addTask(globals()['data_task_'+_id]) # Add task to global queue
            taskList.append(globals()['data_task_'+_id]) # Add task to local list
            
            meta_link = next(link for link in links if link["rel"] == "describedBy")
            globals()['definition_task_'+_id] = QgsTask.fromFunction(
                "Getting " + _id + " collection definition",
                self.requestHandler.get_request_parallel,
                _id, "definition", meta_link["href"], 50
            )
            QgsApplication.taskManager().addTask(globals()['definition_task_'+_id])
            taskList.append(globals()['definition_task_'+_id])
        
        if not taskList:
            # If no tasks were created, request failed (since it failed to fetch the data or definition)
            return self._get_request_base_error({"error_text": "Error in fetching data from server"}, 
                                         "Unable to read collections data", progress)

        """
        Loop through all tasks and wait for them to finish
        _id_data_response_map = map of collectionName and data responses.
        _id_meta_response_map = map of collectionName and definition responses.
        Response maps are used to store the responses of the tasks
        All tasks have finished when the length of response maps = number of tasks/2 = number of collections

        Need to use this manual method, instead of QgsTaskManager.countActiveTasks(), since the latter does not work properly with plugins
        neither does QgsTask.isActive() or QgsTask.isCanceled() work properly
        """
        progress.next("Loading Dataset ...")
        _id_data_response_map, _id_meta_response_map = {}, {}
        while (len(_id_data_response_map) != len(taskList)//2) or (len(_id_meta_response_map) != len(taskList)//2): 
            for task in taskList:
                _id, request_type = task.args[0], task.args[1] # Get the collectionName and requestType from the task
                if request_type == "data": # If the task is a data task
                    if _id in _id_data_response_map: # If we have already stored the response in response map
                        continue
                    elif task.returned_values is not None: # If the task finished, store the response in response map
                        _id_data_response_map[_id] = task.returned_values
                        progress.next("Loading Dataset ...")
                    elif task.exception is not None: # If the task failed, store the error in response map
                        error_json = {"error_text":task.exception, "success":False, "response":None}
                        _id_data_response_map[_id] = error_json
                        break
                elif request_type == "definition": # If the task is a definition task
                    if _id in _id_meta_response_map: # If we have already stored the response in response map
                        continue
                    elif task.returned_values is not None: # If the task finished, store the response in response map
                        _id_meta_response_map[_id] = task.returned_values
                        progress.next("Loading Dataset ...")
                    elif task.exception is not None: # If the task failed, store the error in response map
                        error_json = {"error_text":task.exception, "success":False, "response":None}
                        _id_meta_response_map[_id] = error_json
                        break

        QgsApplication.taskManager().cancelAll() # Cancel all tasks

        _id_layer_map = {} # Map of collectionName and layer
        for _id in collection_order + other_collections:
            meta_response = _id_meta_response_map[_id]
            success = self._get_request_base_error(meta_response, "Unable to read {} collection definition".format(_id), progress) # Handle error
            if not success:
                self.logger.QLogDebug("Unable to read {} collection definition".format(_id))
                return
            self.logger.QLogDebug("Loading {} collection definition".format(_id))
            self.load_items_definition(_id, meta_response) # Load the definition of the collection
            if _id in enums_collection: # If the collection is an enum collection, load the enum definition
                attr_name_list, v_layer_list = self.load_enums_definition(meta_response, enums_set)
                for attr_name in attr_name_list: enums_set.add(attr_name)
                for v_layer in v_layer_list: enums_group.addLayer(v_layer)
            
            data_response = _id_data_response_map[_id]
            success = self._get_request_base_error(data_response, "Unable to read {} collection".format(_id), progress) # Handle error
            if not success:
                self.logger.QLogDebug("Unable to read {} collection".format(_id))
                return
            self.logger.QLogDebug("Loading {} collection".format(_id))
            layer = self.load_items(_id, data_response, self.base_group, id_map) # Load the data of the collection into a layer
            _id_layer_map[_id] = layer
        
        self.logger.QLogInfo("Loading collections successful!")
        self.logger.QLogInfo('\t'.join(['{}: {}'.format(_id, _id_layer_map[_id].featureCount()) 
                                        for _id in collection_order + other_collections]))
        
        for _id, layer in _id_layer_map.items():
            if _id == Constants.COLLECTIONS.LVL:
                level_layer = layer
            elif _id == Constants.COLLECTIONS.CTG:
                category_layer = layer
            elif _id == Constants.COLLECTIONS.DIR:
                directoryInfo_layer = layer
            elif _id == Constants.COLLECTIONS.UNIT:
                unit_layer = layer
            elif _id == Constants.COLLECTIONS.AEL:
                areaElement_layer = layer
            elif _id == Constants.COLLECTIONS.STR:
                structure_layer = layer
            elif _id == Constants.COLLECTIONS.OPN:
                opening_layer = layer
            elif _id == Constants.COLLECTIONS.LEL:
                lineElement_layer = layer
            elif _id == Constants.COLLECTIONS.PEL:
                pointElement_layer = layer
            elif _id == Constants.COLLECTIONS.FCL:
                facility_layer = layer
            elif _id == Constants.COLLECTIONS.VRT:
                verticalPenetration_layer = layer
            elif _id == Constants.COLLECTIONS.ZONE:
                zone_layer = layer
        
        if level_layer is None or len(level_layer) == 0 or unit_layer is None:
            self.msgBar.pushMessage(
                "Error",
                "One or more required collections is missing. Please try again later.",
                level=Qgis.Critical,
                duration=0,
            )
            self._getFeaturesButton_setEnabled(True)
            return

        progress.next("Adding Creator attributes")
        self.logger.QLogInfo("Adding Creator attributes")

        # Populate relational map
        self.relation_map["category"] = "categoryId"
        self.relation_map["unit"] = "unitId"
        self.relation_map["level"] = "levelId"
        self.relation_map["facility"] = "facilityId"
        self.relation_map["address"] = "addressId"

        # Setup Configs
        category_config = {
            "Layer": category_layer,
            "LayerName": category_layer.name(),
            "Key": "id",
            "Value": "name",
            "OrderByValue": True,
        }
        unit_config = {
            "Layer": unit_layer,
            "LayerName": unit_layer.name(),
            "Key": "id",
            "Value": "name",
            "OrderByValue": True,
        }
        level_config = {
            "Layer": level_layer,
            "LayerName": level_layer.name(),
            "Key": "id",
            "Value": "name",
            "OrderByValue": True,
        }
        facility_config = {
            "Layer": facility_layer,
            "LayerName": facility_layer.name(),
            "Key": "id",
            "Value": "name",
            "OrderByValue": True,
        }
        directory_config = {
            "Layer": directoryInfo_layer,
            "LayerName": directoryInfo_layer.name(),
            "Key": "id",
            "Value": "name",
            "OrderByValue": True,
        }

        self.level_to_ordinal = {
            level["id"]: level["ordinal"] for level in level_layer.getFeatures()
        }
        self.ordinal_to_level = {
            level["ordinal"]: level["id"] for level in level_layer.getFeatures()
        }

        # Level layer
        self.logger.QLogDebug("Adding level layer attributes")
        floor_index = self.add_helper_attributes(level_layer)
        fac_index = self.add_widget(
            level_layer, "facility", "ValueRelation", facility_config
        )
        cat_index = self.add_widget(
            level_layer, "category", "ValueRelation", category_config
        )

        ordinals = []
        for feature in level_layer.getFeatures():
            ordinal = str(feature["ordinal"])
            level_layer.changeAttributeValue(feature.id(), floor_index, ordinal)
            level_layer.changeAttributeValue(
                feature.id(),
                cat_index,
                feature.attribute(self.relation_map["category"]),
            )
            level_layer.changeAttributeValue(
                feature.id(),
                fac_index,
                feature.attribute(self.relation_map["facility"]),
            )
            ordinals.append(ordinal)
        self.add_layer_events(level_layer, id_map)

        for ordinal in ordinals:
            self.level_picker.append(ordinal)

        # Unit layer
        self.logger.QLogDebug("Adding unit layer attributes")
        if self.ontology == Ontology.FACILITY_1:
            self._set_widget_layer_id(unit_layer, "navigableBy")
            self._set_widget_layer_id(unit_layer, "routeThroughBehavior")

        self.space_to_floors = {}
        space_to_ordinals = {}

        floor_index = self.add_helper_attributes(unit_layer)
        cat_index = self.add_widget(
            unit_layer, "category", "ValueRelation", category_config
        )
        lvl_index = self.add_widget(unit_layer, "level", "ValueRelation", level_config)
        dir_index = self.add_widget(
            unit_layer, "address", "ValueRelation", directory_config
        )

        for feature in unit_layer.getFeatures():
            levelId = feature["levelId"]
            ordinal = self.level_to_ordinal[levelId]
            floor = ordinal
            unit_layer.changeAttributeValue(feature.id(), floor_index, floor)
            unit_layer.changeAttributeValue(
                feature.id(),
                cat_index,
                feature.attribute(self.relation_map["category"]),
            )
            unit_layer.changeAttributeValue(
                feature.id(), lvl_index, feature.attribute(self.relation_map["level"])
            )
            unit_layer.changeAttributeValue(
                feature.id(), dir_index, feature.attribute(self.relation_map["address"])
            )
            self.space_to_floors[feature["id"]] = floor
            space_to_ordinals[feature["id"]] = ordinal
        self.add_layer_events(unit_layer, id_map)
        print('Unit Layer')

        # Structure layer
        self.logger.QLogDebug("Adding structure layer attributes")
        if structure_layer is not None:
            floor_index = self.add_helper_attributes(structure_layer)
            cat_index = self.add_widget(
                structure_layer, "category", "ValueRelation", category_config
            )
            lvl_index = self.add_widget(
                structure_layer, "level", "ValueRelation", level_config
            )
            for feature in structure_layer.getFeatures():
                levelId = feature["levelId"]
                floor = self.level_to_ordinal[levelId]
                structure_layer.changeAttributeValue(feature.id(), floor_index, floor)
                structure_layer.changeAttributeValue(
                    feature.id(),
                    cat_index,
                    feature.attribute(self.relation_map["category"]),
                )
                structure_layer.changeAttributeValue(
                    feature.id(),
                    lvl_index,
                    feature.attribute(self.relation_map["level"]),
                )
            self.add_layer_events(structure_layer, id_map)

        # Area element layer
        self.logger.QLogDebug("Adding area element layer attributes")
        cat_index = self.add_widget(
            areaElement_layer, "category", "ValueRelation", category_config
        )
        unit_index = self.add_widget(
            areaElement_layer, "unit", "ValueRelation", unit_config
        )

        for feature in areaElement_layer.getFeatures():
            areaElement_layer.changeAttributeValue(
                feature.id(),
                cat_index,
                feature.attribute(self.relation_map["category"]),
            )
            areaElement_layer.changeAttributeValue(
                feature.id(), unit_index, feature.attribute(self.relation_map["unit"])
            )
        self.add_floors_values(
            areaElement_layer, id_map
        )

        # Line element layer
        self.logger.QLogDebug("Adding line element layer attributes")
        cat_index = self.add_widget(
            lineElement_layer, "category", "ValueRelation", category_config
        )
        unit_index = self.add_widget(
            lineElement_layer, "unit", "ValueRelation", unit_config
        )

        for feature in lineElement_layer.getFeatures():
            lineElement_layer.changeAttributeValue(
                feature.id(),
                cat_index,
                feature.attribute(self.relation_map["category"]),
            )
            lineElement_layer.changeAttributeValue(
                feature.id(), unit_index, feature.attribute(self.relation_map["unit"])
            )
        self.add_floors_values(
            lineElement_layer, id_map
        )

        # Point element layer
        self.logger.QLogDebug("Adding point element layer attributes")
        cat_index = self.add_widget(
            pointElement_layer, "category", "ValueRelation", category_config
        )
        unit_index = self.add_widget(
            pointElement_layer, "unit", "ValueRelation", unit_config
        )

        for feature in pointElement_layer.getFeatures():
            pointElement_layer.changeAttributeValue(
                feature.id(),
                cat_index,
                feature.attribute(self.relation_map["category"]),
            )
            pointElement_layer.changeAttributeValue(
                feature.id(), unit_index, feature.attribute(self.relation_map["unit"])
            )
        self.add_floors_values(
            pointElement_layer, id_map
        )

        # Vertical Penetration layer
        self.logger.QLogDebug("Adding vertical penetration layer attributes")
        if self.ontology == Ontology.FACILITY_1:
            self._set_widget_layer_id(unit_layer, "direction")
            self._set_widget_layer_id(unit_layer, "navigableBy")

        if verticalPenetration_layer is not None:
            floor_index = self.add_helper_attributes(verticalPenetration_layer)
            cat_index = self.add_widget(
                verticalPenetration_layer, "category", "ValueRelation", category_config
            )
            lvl_index = self.add_widget(
                verticalPenetration_layer, "level", "ValueRelation", level_config
            )

            for feature in verticalPenetration_layer.getFeatures():
                levelId = feature["levelId"]
                floor = self.level_to_ordinal[levelId]
                verticalPenetration_layer.changeAttributeValue(
                    feature.id(), floor_index, str(floor)
                )
                verticalPenetration_layer.changeAttributeValue(
                    feature.id(),
                    cat_index,
                    feature.attribute(self.relation_map["category"]),
                )
                verticalPenetration_layer.changeAttributeValue(
                    feature.id(),
                    lvl_index,
                    feature.attribute(self.relation_map["level"]),
                )
            self.add_layer_events(verticalPenetration_layer, id_map)

        # Opening layer
        self.logger.QLogDebug("Adding opening layer attributes")
        if opening_layer is not None:
            if self.ontology == Ontology.FACILITY_1:
                self._set_widget_layer_id(opening_layer, "navigableBy")
                self._set_widget_layer_id(opening_layer, "accessLeftToRight")
                self._set_widget_layer_id(opening_layer, "accessRightToLeft")

            floor_index = self.add_helper_attributes(opening_layer)
            cat_index = self.add_widget(
                opening_layer, "category", "ValueRelation", category_config
            )
            lvl_index = self.add_widget(
                opening_layer, "level", "ValueRelation", level_config
            )

            for feature in opening_layer.getFeatures():
                levelId = feature["levelId"]
                floor = self.level_to_ordinal[levelId]
                opening_layer.changeAttributeValue(
                    feature.id(), floor_index, str(floor)
                )
                opening_layer.changeAttributeValue(
                    feature.id(),
                    cat_index,
                    feature.attribute(self.relation_map["category"]),
                )
                opening_layer.changeAttributeValue(
                    feature.id(),
                    lvl_index,
                    feature.attribute(self.relation_map["level"]),
                )
            self.add_layer_events(opening_layer, id_map)

        # Facility layer
        self.logger.QLogDebug("Adding facility layer attributes")
        if facility_layer is not None:
            cat_index = self.add_widget(
                facility_layer, "category", "ValueRelation", category_config
            )
            dir_index = self.add_widget(
                facility_layer, "address", "ValueRelation", directory_config
            )

            for feature in facility_layer.getFeatures():
                facility_layer.changeAttributeValue(
                    feature.id(),
                    cat_index,
                    feature.attribute(self.relation_map["category"]),
                )
                facility_layer.changeAttributeValue(
                    feature.id(),
                    dir_index,
                    feature.attribute(self.relation_map["address"]),
                )
            self.add_layer_events(facility_layer, id_map)

            # Update the layer group name w/ facility_layer name or ID
            self._update_layer_group_name(layer)

        # Category Layer
        self.logger.QLogDebug("Adding category layer attributes")
        if category_layer is not None:
            if self.ontology == Ontology.FACILITY_1:
                self._set_widget_layer_id(category_layer, "navigableBy")
            self.add_layer_events(category_layer, id_map)

        # Directory Info layer
        self.logger.QLogDebug("Adding directory info layer attributes")
        if directoryInfo_layer is not None:
            self.add_layer_events(directoryInfo_layer, id_map)

        # Zone layer
        self.logger.QLogDebug("Adding zone layer attributes")
        if zone_layer is not None:
            floor_index = self.add_helper_attributes(zone_layer)
            cat_index = self.add_widget(
                zone_layer, "category", "ValueRelation", category_config
            )
            lvl_index = self.add_widget(
                zone_layer, "level", "ValueRelation", level_config
            )
            for feature in zone_layer.getFeatures():
                levelId = feature["levelId"]
                floor = self.level_to_ordinal[levelId]
                zone_layer.changeAttributeValue(feature.id(), floor_index, floor)
                zone_layer.changeAttributeValue(
                    feature.id(),
                    cat_index,
                    feature.attribute(self.relation_map["category"]),
                )
                zone_layer.changeAttributeValue(
                    feature.id(),
                    lvl_index,
                    feature.attribute(self.relation_map["level"]),
                )
            self.add_layer_events(zone_layer, id_map)

        if level_layer is None or unit_layer is None:
            self.msgBar.pushMessage(
                "Error",
                "One or more required collections is missing.",
                level=Qgis.Critical,
                duration=0,
            )
            return

        # Set canvas CRS to WGS84 Pseudo-Mercator
        canvas_crs = QgsCoordinateReferenceSystem(Constants.CRS_WGS84)
        self.iface.mapCanvas().setDestinationCrs(canvas_crs)

        self._getFeaturesButton_setEnabled(True)

        # zoom into unit layer after loading complete
        self.iface.setActiveLayer(unit_layer)
        self.iface.zoomToActiveLayer()

        # Clean up to filter features by level and reset initial level to 0 if possible
        self.level_picker.set_base_ordinal(0)
        self.floor_picker_changed(self.level_picker.get_index())

        self.logger.QLogInfo("{} Datset successfully loaded {}".format('-'*10, '-'*10))
        # Close progress dialog
        self._progress_base.close()

    def add_widget(self, layer, fieldName, widgetType, config={}):
        levelsIndex = layer.dataProvider().fieldNameIndex(fieldName)
        if levelsIndex == -1:
            layer.startEditing()
            widget = QgsEditorWidgetSetup(widgetType, config)
            field = QgsField(fieldName, QVariant.String)
            layer.dataProvider().addAttributes([field])
            layer.updateFields()
            layer.setEditorWidgetSetup(
                layer.dataProvider().fieldNameIndex(fieldName), widget
            )
            return layer.dataProvider().fieldNameIndex(fieldName)
        return levelsIndex

    # Adds floors and name attributes and returns the index of the first field added (floors).
    def add_helper_attributes(self, layer):
        floor = layer.dataProvider().fieldNameIndex("floor")
        if floor == -1:
            layer.startEditing()
            provider = layer.dataProvider()
            field = QgsField("floor", QVariant.String)
            provider.addAttributes([field])
            layer.updateFields()
            hiddenWidget = QgsEditorWidgetSetup("Hidden", {})
            layer.setEditorWidgetSetup(max(provider.attributeIndexes()), hiddenWidget)
            # print(provider.fields()[max(provider.attributeIndexes())].editorWidgetSetup().type())
            return max(provider.attributeIndexes())
        else:
            return floor

    def add_floors_values(self, layer, id_map):
        if layer is None:
            return False

        floor_index = self.add_helper_attributes(layer)

        for feature in layer.getFeatures():
            unitId = feature["unitId"]
            if unitId is not None:
                # unitId = json.loads(unitId)
                # unitId = str(unitId["prefix"]) + str(unitId["id"])
                floor = self.space_to_floors.get(unitId, None)
                if floor is not None:
                    layer.changeAttributeValue(feature.id(), floor_index, str(floor))

        self.add_layer_events(layer, id_map)
        return True

    def add_layer_events(self, layer, id_map):
        layer.commitChanges()
        layer.beforeCommitChanges.connect(
            lambda: self.on_before_commit_changes(layer, id_map)
        )
        layer.committedFeaturesAdded.connect(
            lambda: self.committed_features_added(layer, id_map)
        )
        layer.featuresDeleted.connect(
            lambda fids: self.on_features_deleted(fids, layer, id_map)
        )
        layer.featureAdded.connect(lambda fid: self.on_feature_added(fid, layer))
        layer.attributeValueChanged.connect(
            lambda fid: self.on_attributes_changed(fid, layer)
        )
        layer.updatedFields.connect(lambda: self.on_fields_changed(layer))

    def load_items(self, name, response, group, id_map):
        layer = None            
        # Load into a new layer, letting OGR take care of GeoJSON details.
        new_layer = QgsVectorLayer(json.dumps(response), "temp", "ogr")
        crs = new_layer.crs().toWkt()

        # If it's the first page, create the memory layer from the WFS temp layer.
        if layer is None:
            wkb_type = new_layer.wkbType()
            if wkb_type == QgsWkbTypes.NoGeometry:
                wkt = "NoGeometry"
            elif wkb_type == QgsWkbTypes.Point:
                wkt = "Point"
            elif wkb_type == QgsWkbTypes.MultiPoint:
                wkt = "MultiPoint"
            elif wkb_type == QgsWkbTypes.LineString:
                wkt = "LineString"
            elif wkb_type == QgsWkbTypes.MultiLineString:
                wkt = "MultiLineString"
            elif wkb_type == QgsWkbTypes.Polygon:
                wkt = "Polygon"
            elif wkb_type == QgsWkbTypes.MultiPolygon:
                wkt = "MultiPolygon"
            else:
                return name, None

            # layer = QgsVectorLayer(wkt + "?crs=" + crs + "&index=yes", name, "memory")
            maplayer = QgsLayerDefinition.loadLayerDefinitionLayers(
                self.plugin_dir + "/defs/" + self.ontology.value + "/" + name + ".qlr"
            )
            if len(maplayer) != 0:
                layer = maplayer[0]
            else:
                layer = QgsVectorLayer(
                    wkt + "?crs=" + crs + "&index=yes", name, "memory"
                )
            # Add fields to layer - if API returns more attributes than qlr definition
                
            layer.dataProvider().addAttributes(
                new_layer.dataProvider().fields().toList()
            )
            
            QgsProject.instance().addMapLayer(layer, False)
            group.addLayer(layer)
            layer.updateFields()

        # Append the temp layer features to the memory layer.
        layer.startEditing()

        # Append additional fields to API-loaded layer if fields from QLR file is not found
        qlr_fields = [field for field in layer.fields()]
        api_fields_name_set = set([field.name() for field in new_layer.fields()])
        for qlr_field in qlr_fields:
            if qlr_field.name() not in api_fields_name_set:
                field_type = qlr_field.type()
                if field_type == QVariant.String:
                    set_expression = ""
                elif field_type == QVariant.Bool:
                    set_expression = "False"
                else:
                    set_expression = None
                new_layer.addExpressionField(set_expression, qlr_field)

        success = layer.addFeatures(new_layer.getFeatures())

        # Remove anchorPoint until new customer requirements
        attrIndexesToBeRemoved = []
        anchorIndex = layer.dataProvider().fieldNameIndex("anchorPoint")
        if anchorIndex != -1:
            attrIndexesToBeRemoved.append(anchorIndex)
        if len(attrIndexesToBeRemoved) != 0:
            result = layer.dataProvider().deleteAttributes(attrIndexesToBeRemoved)
            layer.updateFields()
        layer.commitChanges()

        for feature in layer.getFeatures():
            id_map[layer.name() + ":" + str(feature.id())] = feature["id"]

        return layer

    def load_items_definition(self, _id, resp):
        """
        Load collection definition
        Save schema map for writing features
        """
        response = resp["response"]
        properties = response["properties"]
        names = []
        for attrs in properties:
            names.append(attrs["name"])
        self.schema_map[_id] = names

    def load_enums_definition(self, resp, enums_set):
        """Load enums definition"""
        response = resp["response"]
        properties = response.get("properties")
        attr_name_list, v_layer_list = [], []
        for attrs in properties:
            attr_type = attrs.get("type")
            attr_name = attrs.get("name")

            if not isinstance(attr_type, dict):
                continue
            if not isinstance(attr_type.get("array"), dict) and not isinstance(
                attr_type.get("enum"), list
            ):
                continue

            enum_list = attr_type.get(
                "enum", attr_type.get("array", {}).get("enum")
            )
            if not enum_list or not attr_name or attr_name in enums_set:
                continue

            v_layer = QgsVectorLayer(
                "None?field=" + attr_name + ":string(0,0)", attr_name, "memory"
            )
            QgsProject.instance().addMapLayer(v_layer, False)
            v_layer.startEditing()
            for enum_value in enum_list:
                feature = QgsFeature()
                feature.setAttributes([enum_value])
                v_layer.addFeature(feature)
            v_layer.commitChanges()
            self.enum_ids[attr_name] = v_layer.id()
            attr_name_list.append(attr_name)
            v_layer_list.append(v_layer)
        return attr_name_list, v_layer_list

    ### Implenented this before but commenting it out for now since not used
    # def format_response_progress(self, id_list, _id_meta_response_map, _id_data_response_map):
    #     def _single_response(_id, request_type, response_mapping):
    #         if _id in response_mapping: return "Done"
    #         else: return "Fetching {}".format(request_type)

    #     max_id_length = max([len(_id) for _id in id_list]) + 2
    #     def_string_length = len("Fetching definition")
    #     response_list = []
    #     for _id in id_list:
    #         response_list.append("{:>{max_id_length}} : {:>{def_string_length}}, {}".format(
    #             _id, 
    #             _single_response(_id, "definition", _id_meta_response_map),
    #             _single_response(_id, "data", _id_data_response_map),
    #             max_id_length=max_id_length, def_string_length=def_string_length
    #         ))
    #     return '\n'.join(response_list)

    def on_fields_changed(self, layer):
        self.dialogBox.QMessageWarn(
            title="Change fields",
            text="Fields are immutable on {} layer.".format(layer.name()),
            detailedText="""Please do not manually change fields on this layer. 
                            Otherwise, you may experience failures on saving your data.""",
        )

    def on_feature_added(self, fid, layer):
        feature = layer.getFeature(fid)
        websiteIndex = feature.fieldNameIndex("website")
        nameIndex = feature.fieldNameIndex("name")
        setIdIndex = feature.fieldNameIndex("setId")
        if websiteIndex != -1:
            website = str(feature.attribute("website") or "")
            if (
                website
                and website != "NULL"
                and not ValidationUtility.validateWebsite(website)
            ):
                self.msgBar.pushMessage(
                    "Warning",
                    "'"
                    + website
                    + "' is not a valid website, please fix it in the attribute table before continuing to edit.",
                    level=Qgis.Warning,
                    duration=0,
                )
                self.areAllFieldsValid = False
                return
        if nameIndex != -1:
            if (
                layer.name() == "category"
                or layer.name() == "directoryInfo"
                or layer.name() == "unit"
                or layer.name() == "level"
            ):
                name = str(feature.attribute("name") or "")
                if not (name and name.strip()) or name == "NULL":
                    self.msgBar.pushMessage(
                        "Warning",
                        "'name' cannot be null or empty on "
                        + layer.name()
                        + " layer, please fix it in the attribute table before continuing to edit.",
                        level=Qgis.Warning,
                        duration=0,
                    )
                    self.areAllFieldsValid = False
                    return
        if setIdIndex != -1:
            if layer.name() == "zone" or layer.name() == "verticalPenetration":
                setId = str(feature.attribute("setId") or "")
                if not (setId and setId.strip()) or setId == "NULL":
                    self.msgBar.pushMessage(
                        "Warning",
                        "'setId' cannot be null or empty on "
                        + layer.name()
                        + " layer, please fix it in the attribute table before continuing to edit.",
                        level=Qgis.Warning,
                        duration=0,
                    )
                    self.areAllFieldsValid = False
                    return

    def on_attributes_changed(self, fid, layer):
        feature = layer.getFeature(fid)
        websiteIndex = feature.fieldNameIndex("website")
        nameIndex = feature.fieldNameIndex("name")
        setIdIndex = feature.fieldNameIndex("setId")
        if websiteIndex != -1:
            website = str(feature.attribute("website") or "")
            if (
                website
                and website != "NULL"
                and not ValidationUtility.validateWebsite(website)
            ):
                self.msgBar.pushMessage(
                    "Warning",
                    "'"
                    + website
                    + "' is not a valid website, please fix it in the attribute table before continuing to edit.",
                    level=Qgis.Warning,
                    duration=0,
                )
                self.areFieldsValid[fid] = False
            else:
                self.areFieldsValid[fid] = True
        if nameIndex != -1:
            if (
                layer.name() == "category"
                or layer.name() == "directoryInfo"
                or layer.name() == "unit"
                or layer.name() == "level"
            ):
                if feature.attribute("name") is None:
                    return
                name = str(feature.attribute("name") or "")
                if not (name and name.strip()) or name == "NULL":
                    self.msgBar.pushMessage(
                        "Warning",
                        "'name' cannot be null or empty on "
                        + layer.name()
                        + " layer, please fix it in the attribute table before continuing to edit.",
                        level=Qgis.Warning,
                        duration=0,
                    )
                    self.areFieldsValid[fid] = False
                else:
                    self.areFieldsValid[fid] = True
        if setIdIndex != -1:
            if layer.name() == "zone" or layer.name() == "verticalPenetration":
                if feature.attribute("setId") is None:
                    return
                setId = str(feature.attribute("setId") or "")
                if not (setId and setId.strip()) or setId == "NULL":
                    self.msgBar.pushMessage(
                        "Warning",
                        "'setId' cannot be null or empty on "
                        + layer.name()
                        + " layer, please fix it in the attribute table before continuing to edit.",
                        level=Qgis.Warning,
                        duration=0,
                    )
                    self.areFieldsValid[fid] = False
                else:
                    self.areFieldsValid[fid] = True

    def on_features_deleted(self, feature_ids, layer, id_map):
        if self.internalDelete:
            self.internalDelete = False
            return

        for fid in feature_ids:
            if fid in self.areFieldsValid.keys():
                self.areFieldsValid.pop(fid)

        edits = layer.editBuffer()
        deletes = edits.deletedFeatureIds()
        for fid in deletes:
            key = layer.name() + ":" + str(fid)
            # raise confirmation dialog for deleting committed features
            if key in id_map:
                warning_response = self.dialogBox.QMessageWarn(
                    title = "Deleting Features in {} layer".format(layer.name()),
                    text = "Are you sure to delete these features?",
                    buttons = QMessageBox.Yes | QMessageBox.Cancel,
                    detailedText="""Please make sure other layers are not referencing these features before deleting them.\n
                        Otherwise, the delete operation will fail and you cannot access those features before loading data again."""
                )
                if warning_response == QMessageBox.Cancel:
                    # Stop a current editing operation and discards any uncommitted edits
                    layer.rollBack()
                    return
                elif warning_response == QMessageBox.Yes:
                    return

    # Use this to access newly created feature after Azure Maps successfully creates a features
    def committed_features_added(self, layer, id_map):
        if not self.areAllFieldsValid:
            return
        
        for fid in self.new_feature_list:
            id_map[layer.name() + ":" + str(fid)] = layer.getFeature(fid)["id"]
        
        self.new_feature_list = []
    
    def on_before_commit_changes(self, layer, id_map):
        """
        Signal sent by QGIS when the save button is clicked on Attribute table or commitChanges() is called.
        Runs before the changes are committed to the data provider.
        For detailed workflow, see (../docs/commit-changes-workflow.md)
        
        Steps:
            1. Check field validity
            2. Gathers Edits, Deletes and Creates.
            3. Rollback Changes
            4. Commit changes to Feature Service
            5. Apply Updates to QGIS
            5. Handle Error
        """
        self.logger.QLogInfo("{} Committing Changes {}".format('-'*10, '-'*10))

        # ----------------- Check field validity ----------------- #
        self._check_field_validity()

        # ----------------- Gathers Edits, Deletes and Creates ----------------- #
        addCommit, editCommit, deleteCommit = self._consolidate_changes(layer, id_map)

        # ---------------------- Rollback Changes ---------------------- #
        layer.editBuffer().rollBack()

        # ---------------------- Commit changes to Feature Service ---------------------- #
        failAdd, failEdit, failDelete = self._commit_changes(layer, addCommit, editCommit, deleteCommit)

        # ---------------------- Handle Updates ---------------------- #
        self._apply_updates(layer)

        # ---------------------- Handle Error ---------------------- #
        self._handle_errors(layer, failAdd, failEdit, failDelete)

    def _check_field_validity(self):
        """Check validity of fields. Throw Error if not valid."""
        # Check if all fields are valid (when edits happen, fields can become invalid)
        if len(self.areFieldsValid) > 0:
            self.areAllFieldsValid = True
            for v in self.areFieldsValid.values():
                self.areAllFieldsValid &= v

        # areAllFieldsValid is an instance variable used in methods like on_features_added
        # Ensures that Field validation is successful.
        if not self.areAllFieldsValid:
            self.dialogBox.QMessageCrit(
                title="Field validation failed", 
                text="Some fields you provided are not valid. Please correct them before saving the feature.",
                detailedText="Some fields you provided are not valid. See Logs for more details.")

    def _get_changes(self, layer):
        """ Gather Creates, Edits and Deletes"""
        editBuffer = layer.editBuffer()
        deletes = editBuffer.deletedFeatureIds()
        adds = editBuffer.addedFeatures()

        # Determine changed features.
        edits = set()
        for fid in editBuffer.changedGeometries():
            edits.add(fid)
        for fid in editBuffer.changedAttributeValues():
            edits.add(fid)
        for fid in deletes:
            edits.discard(fid)
        
        return adds, edits, deletes

    def _consolidate_changes(self, layer, id_map):
        """
        Consolidate changes and return a list of changes to be committed.

        Steps:
            1. Gather edits, deletes and creates
            2. Prepare exporter to export features to GeoJSON
            3. Loop through changes and add store them in respective commit list 
        """

        # ----------------- Gather edits, deletes and creates ----------------- #
        adds, edits, deletes = self._get_changes(layer)

        # ----------------- Get GeoJSON Feature Exporter ----------------- #
        exporter = self._get_feature_exporter(layer, adds, edits)

        # ---------------------- Loop through changes and add store them in respective commit list ---------------------- #
        addCommit, editCommit, deleteCommit = [], [], []
        # Loop through Creates
        for fid in adds:
            self.update_ids(layer, layer.getFeature(fid))
            feature = layer.getFeature(fid)
            featureJson = self._export_feature(exporter, feature, feature['id']) # Export feature to GeoJSON
            addCommit.append((fid, feature, featureJson))

        # Loop through Edits
        for fid in edits:
            self.update_ids(layer, layer.getFeature(fid))
            feature = layer.getFeature(fid)
            key = layer.name() + ":" + str(fid)

            # If ID is a change, take that ID, else take the newly added id
            if fid > 0 and key in id_map: 
                temp_id = id_map[key]
                featureJson = self._export_feature(exporter, feature, temp_id) # Export feature to GeoJSON
                oldFeature = next(layer.dataProvider().getFeatures(QgsFeatureRequest().setFilterFid(fid)))
                editCommit.append((fid, temp_id, feature, oldFeature, featureJson))
            else: 
                adds[fid] = None # Remove ID from adds, to not double count, if the change is an add
                featureJson = self._export_feature(exporter, feature, feature['id']) # Export feature to GeoJSON
                addCommit.append((fid, feature, featureJson)) # Add it to the add list
        
        # Loop through Deletes
        for fid in deletes:
            wid = id_map[layer.name() + ":" + str(fid)]
            oldFeature = next(layer.dataProvider().getFeatures(QgsFeatureRequest().setFilterFid(fid)))
            deleteCommit.append((fid, wid, oldFeature))

        return addCommit, editCommit, deleteCommit

    def _compare_feature_changes(self, newFeature, oldFeature):
        """Compares the changes made to a feature
        Returns a dictionary of the changes made to the feature
        """
        changes = {}
        for i,field in enumerate(newFeature.fields()):
            if newFeature[field.name()] != oldFeature[field.name()]:
                changes[field.name()] = (newFeature[field.name()], i)
        return changes

    def _commit_changes(self, layer, addCommit, editCommit, deleteCommit):
        """
        Handles commits to the Feature Service.

        Note: 
            1. Doesn't stop if a request is not successful. Moves on to the next request.
            2. All requests are independent of each other and can occur in any order.
            This is because saving can only happen in one feature class at a time, due to QGIS restrictions
            3. Used PUT in case of Patch as well, since QGIS returns the full feature, and not just the edited parts.
        """

        failAdd, failEdit, failDelete = [], [], []

        layer.startEditing()

        # ---------------------- Commit changes to Feature Service ---------------------- #
        # Looping through creates
        for fid, feature, body_str in addCommit:
            commit_url = Constants.API_Paths.CREATE.format(base=self.features_url, collectionId=layer.name())
            resp = self.requestHandler.post_request(url=commit_url, body=body_str)
            if resp["success"]: 
                layer.addFeature(feature) # Make the commit
            else:
                failAdd.append((fid, feature['id'], resp)) # Add to list of failed commits
                
        # Looping through edits
        for fid, featureId, feature, oldFeature, body_str in editCommit:
            commit_url = Constants.API_Paths.PUT.format(base=self.features_url, collectionId=layer.name(), featureId=featureId)
            resp = self.requestHandler.put_request(url=commit_url, body=body_str)
            if resp["success"]:
                for newFeatureChange, idx in self._compare_feature_changes(feature, oldFeature).values(): # Make the commit
                    layer.changeAttributeValue(fid, idx, newFeatureChange)
                layer.changeAttributeValue(fid, layer.fields().indexFromName("id"), featureId) # Since ID cannot be changed, change it back to the original
                layer.changeGeometry(fid, feature.geometry()) # Update geometry
            else:
                failEdit.append((fid, featureId, resp))

        # Looping through deletes
        for fid, featureId, oldFeature in deleteCommit:
            commit_url = Constants.API_Paths.DELETE.format(base=self.features_url, collectionId=layer.name(), featureId=featureId)
            resp = self.requestHandler.delete_request(url=commit_url)
            if resp["success"]:
                self.internalDelete = True # Mark delete as internal, to skip function
                layer.deleteFeature(fid)
            else:
                failDelete.append((fid, featureId, resp))

        self.logger.QLogInfo("Report for Changes. Adds: {}\tEdits: {}\tDeletes: {}".format(len(addCommit), len(editCommit), len(deleteCommit)))
        self.logger.QLogInfo("\t\tFailures. Adds: {}\tEdits: {}\tDeletes: {}".format(len(failAdd), len(failEdit), len(failDelete)))

        return failAdd, failEdit, failDelete

    def _apply_updates(self, layer):
        """Handle changes to other fields, if any, due to the creates and edits"""

        successAdd, successEdit, _ = self._get_changes(layer)

        # Update the floor field if it exists, for all successful creates and edits
        floor_index = layer.dataProvider().fieldNameIndex("floor")
        if floor_index != -1:
            self.update_floors(successAdd, layer, floor_index)
            self.update_floors(successEdit, layer, floor_index)

        # Update New Features List to populate id_map once features are created
        self.new_feature_list = list(successAdd.keys())

        # (if modified) Update the layer group name w/ updated facility layer
        self._update_layer_group_name(layer)

    def _handle_errors(self, layer, failAdd, failEdit, failDelete):
        """
        Handles the errors from the Feature Service
        """
        # If any errors, display all of them appropriately
        if (len(failAdd)+len(failDelete)+len(failEdit)>0):
            self.logger.writeErrorLogChanges(failAdd, failEdit, failDelete)
            error_list = ["Add Failed \t FeatureId: {} \t Details: {}".format(featureId, resp["error_text"]) for (_, featureId, resp) in failAdd] + \
                        ["Edit Failed \t FeatureId: {} \t Details: {}".format(featureId, resp["error_text"]) for (_, featureId, resp) in failEdit] + \
                        ["Delete Failed \t FeatureId: {} \t Details: {}".format(featureId, resp["error_text"]) for (_, featureId, resp) in failDelete]
            self.dialogBox.QMessageCrit(
                title="Save Failed!",
                text="""Your saves to {} layer has failed!
Edits, deletes or creates have not been saved to your Azure Maps Account.\nPlease fix the issues and try saving again.\n
Logs can be found here: <a href='{}'>{}</a>""".format(layer.name(), self.logger.errorLogFolderPath, self.logger.errorLogFileName),
                detailedText='\n'.join(error_list)
            )
        return

    def _get_feature_exporter(self, layer, adds, edits):
        """Prepare Exporter to export features to GeoJSON"""
        # https://qgis.org/pyqgis/3.8/core/QgsJsonExporter.html
        # Only needed in case we are adding/changing a feature
        exporter = QgsJsonExporter(layer, 7)
        if len(edits) != 0 or len(adds) != 0:
            if len(edits)!=0:
                fid = next(iter(edits)) # Get the first change, if exists
            else:
                fid = next(iter(adds)) # Otherwise get the first add.
            feature = layer.getFeature(fid)
            attributeList = self.schema_map[layer.name()]
            includedList = []
            for attr in attributeList:
                index = feature.fieldNameIndex(attr)
                if index != -1:
                    includedList.append(index)
            exporter.setAttributes(includedList)
        return exporter

    def _export_feature(self, exporter, feature, input_id):
        """Export feature to GeoJSON"""
        # https://qgis.org/pyqgis/3.8/core/QgsJsonExporter.html
        featureJson = json.loads(exporter.exportFeature(feature, {}, input_id))
        featureJson.pop("bbox", None) # Remove bbox property, to not cause unexpected issues in service later
        return json.dumps(featureJson)

    def update_ids(self, layer, feature):
        """Update background facilityId, categoryId, levelId, addressId based on the value in selected box"""
        for key in self.relation_map:
            if feature.fieldNameIndex(key) != -1:
                # Temp fix until schema is changed - PBI 6216025
                if key == "levels_reached":
                    lvl_list = feature.attribute(self.relation_map[key])
                    lvls_reached = feature.attribute(key)
                    for lvl in lvls_reached:
                        if lvl not in lvl_list:
                            lvl_list.append(lvl)
                    layer.changeAttributeValue(
                        feature.id(),
                        feature.fieldNameIndex(self.relation_map[key]),
                        lvl_list,
                    )
                else:
                    layer.changeAttributeValue(
                        feature.id(),
                        feature.fieldNameIndex(self.relation_map[key]),
                        feature.attribute(key),
                    )

    def update_floors(self, fids, layer, floor_index):
        for fid in fids:
            feature = layer.getFeature(fid)
            if feature.fieldNameIndex("levelId") != -1:
                floor = self.level_to_ordinal[feature["levelId"]]
                if floor is not None:
                    layer.changeAttributeValue(
                        layer.getFeature(fid).id(), floor_index, str(floor)
                    )
            elif feature.fieldNameIndex("unitId") != -1:
                unitId = feature["unitId"]
                if unitId is not None:
                    floor = self.space_to_floors.get(unitId, None)
                    if floor is not None:
                        layer.changeAttributeValue(
                            layer.getFeature(fid).id(), floor_index, str(floor)
                        )
            elif feature.fieldNameIndex("ordinal") != -1:
                ordinal = feature["ordinal"]
                if ordinal is not None:
                    layer.changeAttributeValue(
                        layer.getFeature(fid).id(), floor_index, str(ordinal)
                    )

                    if "id" in feature:
                        feature_id = feature["id"]
                        del_ordinal = self.level_to_ordinal[feature_id]
                        self.level_picker.remove(del_ordinal)
                        del self.ordinal_to_level[del_ordinal]

                    for feature in layer.getFeatures():
                        ordinal = feature["ordinal"]
                        self.level_picker.append(ordinal)

                    self.level_to_ordinal[feature["id"]] = feature["ordinal"]
                    self.ordinal_to_level[feature["ordinal"]] = feature["id"]

    def _set_widget_layer_id(self, layer_object, enum_name):
        enum_layer_id = self.enum_ids[enum_name]
        if enum_layer_id:
            layer_object.editFormConfig().setWidgetConfig(
                enum_name, {"Layer": enum_layer_id}
            )

    # Converts QGIS multi-select string to array of strings
    # Ex. 'left' => 'left', 'NULL' => None, False => False, "{}" => []
    # Ex. "{ 'left, 'center', 'right' }" => ['left', 'center', 'right']
    def _qgis_value_converter(self, qgis_value):
        # If it is not a string, passthrough
        if not isinstance(qgis_value, str):
            return qgis_value
        # If NULL string, QGIS treats them as null value
        if qgis_value == "NULL":
            return None
        # If array, QGIS returns with { } instead of [ ]
        if not qgis_value.startswith("{") or not qgis_value.endswith("}"):
            return qgis_value
        # Convert QGIS array into JSON array in string format
        qgis_value = qgis_value[1:-1].split(",")
        if qgis_value[0] == "":
            qgis_value = []
        return qgis_value

    # Converts QGIS string into a valid JSON string
    def _qgis_values_resolver(self, qgis_str):
        # Load QGIS string as a JSON object
        json_obj = json.loads(qgis_str)
        # Retrieve properties
        json_props = json_obj.get("properties", {})
        # Convert properties' values to be valid JSON values
        json_obj["properties"] = dict(
            map(
                lambda item: (item[0], self._qgis_value_converter(item[1])),
                json_props.items(),
            )
        )
        # Remove entries with None value to reduce payload
        json_obj["properties"] = {
            k: v for k, v in json_obj["properties"].items() if v is not None
        }

        # Handle obstruction area
        if "isObstruction" in json_obj["properties"]:
            if json_obj["geometry"]["type"] == "LineString":
                # For LineString, add a small buffer to construct a polygon as obstructionArea
                json_obj["properties"]["obstructionArea"] = (
                    mapping(shape(json_obj["geometry"]).buffer(0.000001))
                    if json_obj["properties"]["isObstruction"]
                    else None
                )
            elif json_obj["geometry"]["type"] == "Polygon":
                # For Polygon, the geometry itself as obstructionArea
                json_obj["properties"]["obstructionArea"] = (
                    json_obj["geometry"]
                    if json_obj["properties"]["isObstruction"]
                    else None
                )

        # Return stringified JSON object
        return json.dumps(json_obj)

    # Initializes level picker at the toolbar
    def _configure_level_picker(self):
        if hasattr(self, "toolbar_level_picker"):
            return
        self.toolbar_level_picker = QComboBox(self.iface.mainWindow())
        self.toolbar_level_picker.setToolTip("Azure Maps Level Control")
        self.toolbar_level_picker.currentIndexChanged.connect(self.floor_picker_changed)
        self.toolbar_level_combobox_action = self.iface.pluginToolBar().addWidget(
            self.toolbar_level_picker
        )
        self.level_picker = LevelPicker(
            [self.toolbar_level_picker, self.dlg.floorPicker]
        )

    def _open_welcome_message(self):
        self.dialogBox.QMessage(icon=QPixmap(":/plugins/azure_maps/media/icon-circle.png"),
            text="Welcome to the Azure Maps Plugin!",
            informativeText='<a href="https://aka.ms/am-qgis-plugin">Azure Maps Plugin Documentation</a>',
            title="Azure Maps",
            windowFlags=Qt.WindowStaysOnTopHint)

    def _getFeaturesButton_setEnabled(self, boolean):
        self.dlg.getFeaturesButton.setEnabled(boolean)
        self.dlg.getFeaturesButton_2.setEnabled(boolean)

    def hideGroup(self, group):
        if isinstance(group, QgsLayerTreeGroup):
            self.hideNode(group)
        elif isinstance(group, (str, unicode)):
            self.hideGroup(self.root.findGroup(group))

    def hideNode(self, node, bHide=True):
        if type(node) in (QgsLayerTreeLayer, QgsLayerTreeGroup):
            index = self.model.node2index(node)
            self.ltv.setRowHidden(index.row(), index.parent(), bHide)
            node.setCustomProperty("nodeHidden", "true" if bHide else "false")
            self.ltv.setCurrentIndex(self.model.node2index(self.root))

    def hideLayer(self, mapLayer):
        if isinstance(mapLayer, QgsMapLayer):
            self.hideNode(self.root.findLayer(mapLayer.id()))

    def _on_layer_removed(self, node, indexFrom, indexTo):
        if node == self.base_group:
            self.level_picker.clear()

    def _update_layer_group_name(self, facility_layer):
        dataset_id = self.dlg.datasetId.text()
        if (
            facility_layer is None
            or not callable(getattr(facility_layer, "name", None))
            or facility_layer.name() != "facility"
        ):
            return
        features = list(facility_layer.getFeatures())
        facility_count = len(features)
        if facility_count > 1:
            self.base_group.setName(
                str(facility_count) + " Facilities | " + str(dataset_id)
            )
        elif facility_count == 1:
            facility_name = features[0]["name"]
            facility_name = (
                facility_name
                if facility_name != NULL and facility_name != ""
                else features[0]["id"]
            )
            self.base_group.setName(str(facility_name) + " | " + str(dataset_id))
        else:
            self.base_group.setName(str(dataset_id))

    def _apply_progress_error_message(self, error_message, progress, messageBar):
        messageBar.pushMessage("Error", error_message, level=Qgis.Critical, duration=0)
        progress.close()
        self._getFeaturesButton_setEnabled(True)

def get_depth(collection_name, references):
    ref_list = references.get(collection_name, None)
    if not ref_list:
        return 0
    return 1 + max(get_depth(key, references) for (key, _) in ref_list)